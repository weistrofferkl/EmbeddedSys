/*
 * mpu6050.c
 * Adapted from jrowberg/i2cdevlib MPU6050
 */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "mpu6050.h"
#include "i2c.h"

//# ===================================================================================================
//# | Default MotionApps v2.0 42-byte FIFO packet structure:                                           |
//# |                                                                                                  |
//# | [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
//# |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
//# |                                                                                                  |
//# | [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ]                         |
//# |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                          |
//# ====================================================================================================

//# this block of memory gets written to the MPU on start-up, and it seems
//# to be volatile memory, so it has to be done each time (it only takes ~1 second though)

    char dmpMemory[] = {
        0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
        0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
        0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
        0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
        0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
        0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
        0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
        0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,


        0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
        0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
        0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
        0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,


        0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,


        0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
        0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
        0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
        0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
        0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
        0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
        0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
        0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
        0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
        0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
        0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
        0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
        0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
        0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
        0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
        0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,


        0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
        0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
        0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
        0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
        0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
        0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
        0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
        0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
        0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
        0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
        0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
        0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
        0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
        0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
        0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
        0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,


        0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
        0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
        0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
        0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
        0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
        0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
        0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
        0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
        0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
        0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
        0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
        0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
        0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
        0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
        0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
        0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,


        0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
        0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
        0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
        0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
        0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
        0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
        0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
        0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
        0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
        0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
        0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
        0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
        0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
        0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
        0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
        0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,


        0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
        0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
        0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
        0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
        0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
        0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
        0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
        0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF};

    char dmpConfig[] = {
        // BANK    OFFSET  LENGTH  [DATA]
        0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,         // FCFG_1 inv_set_gyro_calibration
        0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,         // FCFG_3 inv_set_gyro_calibration
        0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,   // D_0_104 inv_set_gyro_calibration
        0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,   // D_0_24 inv_set_gyro_calibration
        0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,   // D_1_152 inv_set_accel_calibration
        0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_accel_calibration
        0x03,   0x89,   0x03,   0x26, 0x46, 0x66,         // FCFG_7 inv_set_accel_calibration
        0x00,   0x6C,   0x02,   0x20, 0x00,               // D_0_108 inv_set_accel_calibration
        0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_00 inv_set_compass_calibration
        0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_01
        0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_02
        0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_10
        0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_11
        0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_12
        0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_20
        0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_21
        0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,   // CPASS_MTX_22
        0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,   // D_1_236 inv_apply_endian_accel
        0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
        0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,         // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
        0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,   // FCFG_5 inv_set_bias_update
        0x00,   0xA3,   0x01,   0x00,                     // D_0_163 inv_set_dead_zone
        // SPECIAL 0x01 = enable interrupts
        0x00,   0x00,   0x00,   0x01,                     // SET INT_ENABLE at i=22, SPECIAL INSTRUCTION
        0x07,   0x86,   0x01,   0xFE,                     // CFG_6 inv_set_fifo_interupt
        0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
        0x07,   0x7E,   0x01,   0x30,                     // CFG_16 inv_set_footer
        0x07,   0x46,   0x01,   0x9A,                     // CFG_GYRO_SOURCE inv_send_gyro
        0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_9 inv_send_gyro -> inv_construct3_fifo
        0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,   // CFG_12 inv_send_accel -> inv_construct3_fifo
        0x02,   0x16,   0x02,   0x00, 0x09                // D_0_22 inv_set_fifo_rate


        // This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
        // 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data.
        // DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))

        // It is important to make sure the host processor can keep up with reading and processing
        // the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
    };

    char dmpUpdates[] = {
        0x01,   0xB2,   0x02,   0xFF, 0xFF,
        0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
        0x01,   0x6A,   0x02,   0x06, 0x00,
        0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
        0x01,   0x62,   0x02,   0x00, 0x00,
        0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00};



    int fifocount;
    unsigned char DMPFifo[128];
    int DMPIntStatus;

void mpu_write(struct r_i2c &mpu, const int reg, const unsigned char value) {
    unsigned char data[1];
    data[0] = value;
    i2c_master_write_reg(MPU6050_ADDRESS, reg, data, 1, mpu);
}

void mpu_writebit(struct r_i2c &mpu, const int reg, const int bitNum, const unsigned char value) {
    unsigned char data[1];
    data[0] = value;
    i2c_master_writeBit(MPU6050_ADDRESS, reg, bitNum, data, mpu);
}

void mpu_writebits(struct r_i2c &mpu, const int reg, const int bitStart, const int length, const unsigned char value) {
    unsigned char data[1];
    data[0]=value;
    i2c_master_writeBits(MPU6050_ADDRESS, reg, bitStart, length, data, mpu);
}

int mpu_readBits(struct r_i2c &mpu, const int reg, const int bitStart, const int length){
    unsigned char data[1];
    i2c_master_readBits(MPU6050_ADDRESS, reg, bitStart, length, data, mpu);
    return data[0];
}
unsigned char mpu_read_byte(struct r_i2c &mpu, const int reg) {
    unsigned char data[1];
    i2c_master_read_reg(MPU6050_ADDRESS, reg, data, 1, mpu);
    return data[0];
}

unsigned char mpu_read_bytes(struct r_i2c &mpu, const int reg, unsigned char data[], const int length){
    i2c_master_read_reg(MPU6050_ADDRESS, reg, data,length,mpu);
    return 1;
}

short mpu_read_short(struct r_i2c &mpu, const int reg) {
    unsigned char hi = mpu_read_byte(mpu, reg);
    unsigned char lo = mpu_read_byte(mpu, reg+1);
    return  hi << 8 | lo;
}

void mpu_initialize(struct IMU &imu)
{
    mpu_writebits(imu.i2c,MPU6050_RA_PWR_MGMT_1,MPU6050_PWR1_CLKSEL_BIT,MPU6050_PWR1_CLKSEL_LENGTH,MPU6050_CLOCK_PLL_XGYRO);
    mpu_writebits(imu.i2c, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, MPU6050_GYRO_FS_250);
    mpu_writebits(imu.i2c, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, MPU6050_ACCEL_FS_2);
    mpu_writebit(imu.i2c, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 0);
}

void mpu_dumpregs(struct r_i2c &mpu){
    int i;
    unsigned char result;
    for (i=0;i<118;i++){
        result=mpu_read_byte(mpu,i);
        printf("Reg: %.2X Value: %.2X\n",i,result);
        delay_milliseconds(50);
    }
}

void mpu_dmpInitialize(struct IMU &imu){
    int result;

    mpu_initialize(imu);
    printf("Starting DMP Initialization\n");
    mpu_writebit(imu.i2c, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, 1);  //reset
    delay_milliseconds(50);

    mpu_writebit(imu.i2c, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 0);        //disable sleep mode

    mpu_setMemoryBank(imu,0x10,1,1);                                                     //select userbank 16
    mpu_write(imu.i2c,MPU6050_RA_MEM_START_ADDR,0x06);                              //select memory byte 6
    result=mpu_read_byte(imu.i2c,MPU6050_RA_MEM_R_W);
    //printf("Hardware Revision %.2X\n",result);
    mpu_setMemoryBank(imu,0,0,0);

    imu.gyro_x_offset = mpu_readBits(imu.i2c,MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH);
    imu.gyro_y_offset = mpu_readBits(imu.i2c,MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH);
    imu.gyro_z_offset = mpu_readBits(imu.i2c,MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH);
    //printf("gyo_x:%.2x gyo_y:%.2x gyo_z:%.2x\n",imu.gyro_x_offset,imu.gyro_y_offset,imu.gyro_z_offset);

    mpu_write(imu.i2c,MPU6050_RA_I2C_SLV0_ADDR,0x7F);   //set slave address
    mpu_writebit(imu.i2c,MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_EN_BIT,0); //disable i2c master mode
    mpu_write(imu.i2c,MPU6050_RA_I2C_SLV0_ADDR,0x68);   //set slave address
    mpu_writebit(imu.i2c,MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_I2C_MST_RESET_BIT,1); //reset i2c master control
    delay_milliseconds(20);

    //mpu_writebit(imu.i2c, MPU6050_RA_INT_PIN_CFG, MPU6050_INTCFG_I2C_BYPASS_EN_BIT, 1); //enable pass through mode

    //printf("Writing Memory Block\n");
    mpu_writeMemoryBlock(imu, dmpMemory, 1929, 0, 0, 0) ;    // load dmp code into memory banks
    //printf("Loading DMP Configuration\n");
    mpu_writeDMPConfigurationSet(imu,dmpConfig,192,0,0,0);  //load DMP configuration

    mpu_writebits(imu.i2c, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, MPU6050_CLOCK_PLL_ZGYRO); //set clock to z gyro
    mpu_write(imu.i2c, MPU6050_RA_INT_ENABLE, 0x12);  //set DMP and FIFO_OFLOW enabled
    mpu_write(imu.i2c, MPU6050_RA_SMPLRT_DIV, 4);   //sample rate at 200hz - 1khz / (1 + 4) = 200 Hz [9 = 100 Hz]
    mpu_writebits(imu.i2c, MPU6050_RA_CONFIG, MPU6050_CFG_EXT_SYNC_SET_BIT, MPU6050_CFG_EXT_SYNC_SET_LENGTH, MPU6050_EXT_SYNC_TEMP_OUT_L); //set external frame sync
    mpu_writebits(imu.i2c, MPU6050_RA_CONFIG, MPU6050_CFG_DLPF_CFG_BIT, MPU6050_CFG_DLPF_CFG_LENGTH, MPU6050_DLPF_BW_42);  //setting dlpf bandwidth to 42hz
    mpu_writebits(imu.i2c, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, MPU6050_GYRO_FS_2000); //set gyro sensitivity to +/- 2000 deg/sec
    mpu_write(imu.i2c, MPU6050_RA_DMP_CFG_1, 0x03);  //DMP config bytes
    mpu_write(imu.i2c, MPU6050_RA_DMP_CFG_2, 0x00);
    mpu_writebit(imu.i2c, MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OTP_BNK_VLD_BIT, 0); //clear OTP Bank Flag

    mpu_writebits(imu.i2c,MPU6050_RA_XG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH,imu.gyro_x_offset);
    mpu_writebits(imu.i2c,MPU6050_RA_YG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH,imu.gyro_y_offset);
    mpu_writebits(imu.i2c,MPU6050_RA_ZG_OFFS_TC, MPU6050_TC_OFFSET_BIT, MPU6050_TC_OFFSET_LENGTH,imu.gyro_z_offset);
    /*
    mpu_write(imu.i2c, MPU6050_RA_XG_OFFS_USRH, 0x00);  //set gyro offsets to zero
    mpu_write(imu.i2c, MPU6050_RA_XG_OFFS_USRL, 0x00);
    mpu_write(imu.i2c, MPU6050_RA_YG_OFFS_USRH, 0x00);  //set gyro offsets to zero
    mpu_write(imu.i2c, MPU6050_RA_YG_OFFS_USRL, 0x00);
    mpu_write(imu.i2c, MPU6050_RA_ZG_OFFS_USRH, 0x00);  //set gyro offsets to zero
    mpu_write(imu.i2c, MPU6050_RA_ZG_OFFS_USRL, 0x00);
    */

    // Final memory update 1/7
    unsigned char dmpUpdate[16],j,du=0;
    unsigned short pos = 0;
    for (j=0;j<16;j++) dmpUpdate[j]=0;
    j=0;
    while ((j<4) || (j<dmpUpdate[2]+3)){
        dmpUpdate[du]=dmpUpdates[pos];
        j+=1;
        pos+=1;
        du+=1;
    }
    mpu_writeMemoryBlock(imu,dmpUpdate+3,dmpUpdate[2],dmpUpdate[0],dmpUpdate[1],0);
    // Final memory update 2/7
    for (j=0;j<16;j++) dmpUpdate[j]=0;
    du=0;
    j=0;
    while ((j<4) || (j<dmpUpdate[2]+3)){
        dmpUpdate[du]=dmpUpdates[pos];
        j+=1;
        pos+=1;
        du+=1;
    }
    mpu_writeMemoryBlock(imu,dmpUpdate+3,dmpUpdate[2],dmpUpdate[0],dmpUpdate[1],0);

    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1); //reset fifo
    fifocount= mpu_read_short(imu.i2c,MPU6050_RA_FIFO_COUNTH); //current fifo count

    if (fifocount>0) mpu_read_bytes(imu.i2c,MPU6050_RA_FIFO_R_W,DMPFifo,fifocount); //get fifo bytes

    mpu_write(imu.i2c, MPU6050_RA_MOT_THR, 2); //motion detection 2
    mpu_write(imu.i2c, MPU6050_RA_ZRMOT_THR, 156); //set zero motion detection to 156
    mpu_write(imu.i2c, MPU6050_RA_MOT_DUR, 80); //motion duration to 80
    mpu_write(imu.i2c, MPU6050_RA_ZRMOT_DUR, 0); //zero motion duration to 0

    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1); //reset fifo
    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_EN_BIT, 1); //enable fifo
    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, 1); //enable dmp
    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_RESET_BIT, 1); //reset dmp

    // Final memory update 3/7
    for (j=0;j<16;j++) dmpUpdate[j]=0;
    du=0;
    j=0;
    while ((j<4) || (j<dmpUpdate[2]+3)){
        dmpUpdate[du]=dmpUpdates[pos];
        j+=1;
        pos+=1;
        du+=1;
    }
    mpu_writeMemoryBlock(imu,dmpUpdate+3,dmpUpdate[2],dmpUpdate[0],dmpUpdate[1],0);
    // Final memory update 4/7
    for (j=0;j<16;j++) dmpUpdate[j]=0;
    du=0;
    j=0;
    while ((j<4) || (j<dmpUpdate[2]+3)){
        dmpUpdate[du]=dmpUpdates[pos];
        j+=1;
        pos+=1;
        du+=1;
    }
    mpu_writeMemoryBlock(imu,dmpUpdate+3,dmpUpdate[2],dmpUpdate[0],dmpUpdate[1],0);
    // Final memory update 5/7
    for (j=0;j<16;j++) dmpUpdate[j]=0;
    du=0;
    j=0;
    while ((j<4) || (j<dmpUpdate[2]+3)){
        dmpUpdate[du]=dmpUpdates[pos];
        j+=1;
        pos+=1;
        du+=1;
    }
    mpu_writeMemoryBlock(imu,dmpUpdate+3,dmpUpdate[2],dmpUpdate[0],dmpUpdate[1],0);

    while (mpu_read_short(imu.i2c,MPU6050_RA_FIFO_COUNTH) < 3){
        fifocount = mpu_read_short(imu.i2c,MPU6050_RA_FIFO_COUNTH);
    }

    if (fifocount>0) mpu_read_bytes(imu.i2c,MPU6050_RA_FIFO_R_W,DMPFifo,fifocount); //get fifo bytes
    // Final memory update 6/7
    for (j=0;j<16;j++) dmpUpdate[j]=0;
    du=0;
    j=0;
    while ((j<4) || (j<dmpUpdate[2]+3)){
        dmpUpdate[du]=dmpUpdates[pos];
        j+=1;
        pos+=1;
        du+=1;
    }
    mpu_writeMemoryBlock(imu,dmpUpdate+3,dmpUpdate[2],dmpUpdate[0],dmpUpdate[1],0);

    while (mpu_read_short(imu.i2c,MPU6050_RA_FIFO_COUNTH) < 3){
        fifocount = mpu_read_short(imu.i2c,MPU6050_RA_FIFO_COUNTH);
    }
    if (fifocount>0) mpu_read_bytes(imu.i2c,MPU6050_RA_FIFO_R_W,DMPFifo,fifocount); //get fifo bytes
    // Final memory update 7/7
    for (j=0;j<16;j++) dmpUpdate[j]=0;
    du=0;
    j=0;
    while ((j<4) || (j<dmpUpdate[2]+3)){
        dmpUpdate[du]=dmpUpdates[pos];
        j+=1;
        pos+=1;
        du+=1;
    }
    mpu_writeMemoryBlock(imu,dmpUpdate+3,dmpUpdate[2],dmpUpdate[0],dmpUpdate[1],0);

    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, 0); //disable dmp
    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1); //reset fifo
    DMPIntStatus=mpu_read_byte(imu.i2c,MPU6050_RA_INT_STATUS);
    printf("DMP Status: %0.2x\n",DMPIntStatus);
}

void mpu_Stop(struct IMU &imu){
    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, 0); //disable dmp
    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1); //reset fifo
    mpu_writebit(imu.i2c, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, 1);  //reset
    delay_milliseconds(50);

    mpu_writebit(imu.i2c, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1);        //disable sleep mode
}

void mpu_getQuaternion(unsigned char packet[],float quat[]){

    if (packet [0] > 127)  packet[0] -= 256;
    if (packet [4] > 127)  packet[4] -= 256;
    if (packet [8] > 127)  packet[8] -= 256;
    if (packet[12] > 127) packet[12] -= 256;
    short d[4];

    d[0]= (( packet[0] << 8) +  packet[1]);
    d[1]= (( packet[4] << 8) +  packet[5]);
    d[2]= (( packet[8] << 8) +  packet[9]);
    d[3]= ((packet[12] << 8) + packet[13]);

    quat[0]= (float)d[0] / 16384.0f;      //w
    quat[1]= (float)d[1] / 16384.0f;      //x
    quat[2]= (float)d[2] / 16384.0f;      //y
    quat[3]= (float)d[3] / 16384.0f;      //z
}

void mpu_getAccel(unsigned char packet[],short data[]){
    data[0] = (packet[28] << 8) + packet[29];
    data[1] = (packet[32] << 8) + packet[33];
    data[2] = (packet[36] << 8) + packet[37];
}

void mpu_getGyro(unsigned char packet[],short data[]){
    data[0] = (packet[16] << 8) + packet[17];
    data[1] = (packet[20] << 8) + packet[21];
    data[2] = (packet[24] << 8) + packet[25];
}

void mpu_getGravity(float q[],float g[]){
    g[0] = (2 * (q[1] * q[3] - q[0] * q[2]));
    g[1] = (2 * (q[0] * q[1] + q[2] * q[3]));
    g[2] = (q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3]);
}

void mpu_getYawPitchRoll(float q[],float g[],float ypr[]){
        // yaw: (about Z axis)
        ypr[0] = atan2(2 * q[1] * q[2] - 2 * q[0] * q[3], 2 * q[0] * q[0] + 2 * q[1] * q[1] - 1);
        // pitch: (nose up/down, about Y axis)
        ypr[1] = atan(g[0] / sqrt(g[1] * g[1] + g[2] * g[2]));
        // roll: (tilt left/right, about X axis)
        ypr[2] = atan(g[1] / sqrt(g[0] * g[0] + g[2] * g[2]));
}

void mpu_getEuler(float euler[], float q[]){
    euler[0] = (atan2(2*q[1]*q[2] - 2*q[0]*q[3], 2*q[0]*q[0] + 2*q[1]*q[1] - 1));   // psi
    euler[1] = (-asin(2*q[1]*q[3] + 2*q[0]*q[2]));                              // theta
    euler[2] = (atan2(2*q[2]*q[3] - 2*q[0]*q[1], 2*q[0]*q[0] + 2*q[3]*q[3] - 1));   // phi
}

float rad2deg(float rad){
    float pi=3.14159;
    return (180.0 * rad / pi);
}

void mpu_getFIFOBytes(struct IMU &imu,int numbytes,unsigned char fifobuf[]){
    int i;
    unsigned char inbyte;
    for (i=0;i<numbytes;i++){
        inbyte=mpu_read_byte(imu.i2c,MPU6050_RA_FIFO_R_W);
        fifobuf[i]=inbyte;
    }
}

void mpu_writeMemoryBlock(struct IMU &imu, unsigned char data[],int dataSize,int bank,int address,int verify){
    int i,result;
    mpu_setMemoryBank(imu,bank,0,0);
    mpu_write(imu.i2c,MPU6050_RA_MEM_START_ADDR,address);

    i=0;
    while (i<dataSize){

        mpu_write(imu.i2c,MPU6050_RA_MEM_R_W,data[i]);

        // verify
        if (verify){
            mpu_setMemoryBank(imu,bank,0,0);
            mpu_write(imu.i2c,MPU6050_RA_MEM_START_ADDR,address);
            result = mpu_read_byte(imu.i2c,MPU6050_RA_MEM_R_W);

            if (result != data[i]){
                printf("Memory Block-Address:%.2x Writing:%.2x After:%.2x\n",address,data[i],result);
            }
        }

        // reset address to 0 after reaching 255
        if (address == 255){
            address=0;
            bank += 1;
            mpu_setMemoryBank(imu,bank,0,0);
        } else {
            address += 1;
        }

        mpu_write(imu.i2c,MPU6050_RA_MEM_START_ADDR,address);
        i += 1;
    }
}

void mpu_writeDMPConfigurationSet(struct IMU &imu, unsigned char data[], int dataSize, int bank, int address, int verify){
    unsigned char success,special;
    unsigned char *progBuffer=NULL;
    unsigned short i;
    unsigned char offset,length;
    for (i=0;i<dataSize;){
        bank = data[i++];
        offset=data[i++];
        length=data[i++];

        if (length > 0){
            progBuffer = (unsigned char *)data + i;
            mpu_writeMemoryBlock(imu,progBuffer,length,bank,offset,1);
            i += length;
        } else {
            special = data[i++];
            if (special == 0x01){
                mpu_write(imu.i2c,MPU6050_RA_INT_ENABLE, 0x32);  // single operation
                success=1;
            } else {
                success=0;
            }
        }
    }
}

int mpu_setMemoryBank(struct IMU &imu, int bank, const int prefetchEnabled,const int userBank){
    bank &= 0x1F;
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    mpu_write(imu.i2c,MPU6050_RA_BANK_SEL,bank);
    return 1;
}

void mpu_init_i2c(struct IMU &imu){
    i2c_master_init(imu.i2c);
}

void mpu_resetFifo(struct IMU &imu){
    mpu_writebit(imu.i2c, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_FIFO_RESET_BIT, 1); //reset fifo
}

void mpu_enableDMP(struct IMU &imu,int enable){
    mpu_writebit(imu.i2c,MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_DMP_EN_BIT, enable);  //enable DMP
}



